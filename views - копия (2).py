# -*- coding: utf-8 -
from django.shortcuts import render
from django.http import HttpResponse
#from calculator import calculate
from math import pi
from datetime import *
import json
from math import *
#import numpy


def days_z(year, month, day):
    """
    Номер дня от начала года
    вход year - год, month - номер месяца, day - номер день в месяце
    """
    #               ян фе ма ап ма ию ию ав се ок но де
    day_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if year % 4 == 0:
        day_in_month[1]+=1 #високосный год

    sum = 0
    for i in range(month - 1):
        sum+=day_in_month[i]
    sum+=day
    return sum

def calc(request):

 #    lat = 
	#lng = 
	#alt = 
	#data = 
	#h = float(request.GET['h'])
    #header('Content-Type: text/xml')
    north = float(request.GET['lat'])#_GET['lat']
    east = float( request.GET['lng'])#_GET['lng']
    alt = float(request.GET['alt'])#_GET['alt']
    year = float(request.GET['data'])#_GET['data']
        #north = 0   #северная широта (южная со знаком "-")
        #east = 0    # восточная долгота (западная со знаком "-")
        #alt = 0     # высота над уровнем моря, км
        #year = 2015 # текущая дата. (например 30 июня 2015 года запишется 2015.5)
#ФИЗИЧЕСКИЕ (ИНВАРИАНТНЫЕ) ПАРАМЕТРЫ ЗЕМЛИ\n")
    R=6371.032   #Средний радиус Земли, [км]  
    a=6378.245 #Большая полуось Земного элепсоида вращения, [км] # Эллипсоид Красовского
    b=6356.863019 #Малая полуось Земного элепсоида вращения, [км] # Эллипсоид Красовского
    Age=2015.0    #Эпоха        
#***матрицы сферических гармонических коэффициентов (для эпохи 2015г.)
    IGRF_g=[[      0,          0,         0,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [-29438.5,    -1501.1,         0,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [ -2445.3,     3012.5,    1676.6,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [  1351.1,    -2352.3,    1225.6,     581.9,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [   907.2,      813.7,     120.3,    -335.0,     70.3,        0,        0,        0,       0,        0,       0,        0,    0],
        [  -232.6,      360.1,     192.4,    -141.0,   -157.4,      4.3,        0,        0,       0,        0,       0,        0,    0],
        [    69.5,       67.4,      72.8,    -129.8,    -29.0,     13.2,    -70.9,        0,       0,        0,       0,        0,    0],
        [    81.6,      -76.1,      -6.8,      51.9,     15.0,      9.3,     -2.8,      6.7,       0,        0,       0,        0,    0],
        [    24.0,        8.6,     -16.9,      -3.2,    -20.6,     13.3,     11.7,    -16.0,    -2.0,        0,       0,        0,    0],
        [     5.4,        8.8,       3.1,      -3.1,      0.6,    -13.3,     -0.1,      8.7,    -9.1,    -10.5,       0,        0,    0],
        [    -1.9,       -6.5,       0.2,       0.6,     -0.6,      1.7,     -0.7,      2.1,     2.3,     -1.8,    -3.6,        0,    0],
        [     3.1,       -1.5,      -2.3,       2.1,     -0.9,      0.6,     -0.7,      0.2,     1.7,     -0.2,     0.4,      3.5,    0],
        [    -2.0,       -0.3,       0.4,       1.3,     -0.9,      0.9,      0.1,      0.5,    -0.4,     -0.4,     0.2,     -0.9,    0]]

    IGRF_h=[[0,          0,         0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,     4796.2,         0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,    -2845.6,    -642.0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,     -115.3,     245.0,    -538.3,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,      283.4,    -188.6,     180.9,    -329.5,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,       47.4,     196.9,    -119.4,      16.1,    100.1,        0,        0,       0,        0,       0,       0,       0],
         [0,      -20.7,      33.2,      58.8,     -66.5,      7.3,     62.5,        0,       0,        0,       0,       0,       0],
         [0,      -54.1,     -19.4,       5.6,      24.4,      3.3,    -27.5,     -2.3,       0,        0,       0,       0,       0],
         [0,       10.2,     -18.1,      13.2,     -14.6,     16.2,      5.7,     -9.1,      2.2,       0,       0,       0,       0],
         [0,      -21.6,      10.8,      11.7,      -6.8,     -6.9,      7.8,      1.0,     -3.9,     8.5,       0,       0,       0],
         [0,        3.3,      -0.3,       4.6,       4.4,     -7.9,     -0.6,     -4.1,     -2.8,    -1.1,    -8.7,       0,       0],
         [0,       -0.1,       2.1,      -0.7,      -1.1,      0.7,     -0.2,     -2.1,     -1.5,    -2.5,    -2.0,    -2.3,       0],
         [0,       -1.0,       0.5,       1.8,      -2.2,      0.3,      0.7,     -0.1,      0.3,     0.2,    -0.9,    -0.2,     0.7]]
        
    SV_g=[[   0,       0,       0,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [10.7,    17.9,       0,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [-8.6,    -3.3,     2.4,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [ 3.1,    -6.2,    -0.4,   -10.4,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [-0.4,     0.8,    -9.2,     4.0,    -4.2,       0,       0,       0,      0,      0,      0,      0,    0],
       [-0.2,     0.1,    -1.4,     0.0,     1.3,     3.8,       0,       0,      0,      0,      0,      0,    0],
       [-0.5,    -0.2,    -0.6,     2.4,    -1.1,     0.3,     1.5,       0,      0,      0,      0,      0,    0],
       [ 0.2,    -0.2,    -0.4,     1.3,     0.2,    -0.4,    -0.9,     0.3,      0,      0,      0,      0,    0],
       [ 0.0,     0.1,    -0.5,     0.5,    -0.2,     0.4,     0.2,    -0.4,    0.3,      0,      0,      0,    0],
       [ 0.0,    -0.1,    -0.1,     0.4,    -0.5,    -0.1,     0.1,     0.0,   -0.2,   -0.1,      0,      0,    0],
       [ 0.0,     0.0,    -0.1,     0.3,    -0.1,    -0.1,    -0.1,     0.0,   -0.2,   -0.1,   -0.2,      0,    0],
       [ 0.0,     0.0,    -0.1,     0.1,     0.0,     0.0,     0.0,     0.0,    0.0,    0.0,   -0.1,   -0.1,    0],
       [ 0.1,     0.0,     0.0,     0.1,    -0.1,     0.0,     0.1,     0.0,      0,      0,      0,      0,    0]]
           
    SV_h=[[0,        0,        0,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,    -26.8,        0,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,    -27.1,    -13.8,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,      8.4,     -0.4,      2.3,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,     -0.6,      5.3,      3.0,     -5.3,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,      0.4,      1.6,     -1.1,      3.3,      0.1,       0,       0,       0,     0,     0,     0,    0],
       [0,      0.0,     -2.2,     -0.7,      0.1,      1.0,     1.3,       0,       0,     0,     0,     0,    0],
       [0,      0.7,      0.5,     -0.2,     -0.1,     -0.7,     0.1,     0.1,       0,     0,     0,     0,    0],
       [0,     -0.3,      0.3,      0.3,      0.6,     -0.1,    -0.2,     0.3,     0.0,     0,     0,     0,    0],
       [0,     -0.2,     -0.1,     -0.2,      0.1,      0.1,     0.0,    -0.2,     0.4,   0.3,     0,     0,    0],
       [0,      0.1,     -0.1,      0.0,      0.0,     -0.2,     0.1,    -0.1,    -0.2,   0.1,  -0.1,     0,    0],
       [0,        0,      0.1,      0.0,      0.1,      0.0,     0.0,     0.1,     0.0,  -0.1,   0.0,  -0.1,    0],
       [0,        0,        0,     -0.1,      0.0,      0.0,     0.0,     0.0,       0,     0,     0,     0,    0]]

    lamda=east*(pi/180)
    fi=north*(pi/180)
    fi_sh=atan(((pow(b,2)+alt*sqrt(pow(a,2)*pow((cos(fi)),2)+pow(b,2)*pow((sin(fi)),2)))/(pow(a,2)+alt*sqrt(pow(a,2)*pow(cos(fi),2)+pow(b,2)*pow((sin(fi)),2))))*tan(fi))#Широта в сферических координатах
    teta=(pi/2)-fi_sh #Полярный угол
    r=sqrt(pow(alt,2)+2*alt*sqrt(pow(a,2)*pow((cos(fi)),2)+pow(b,2)*pow((sin(fi)),2))+((pow(a,4)*pow((cos(fi)),2)+pow(b,4)*pow((sin(fi)),2))/(pow(a,2)*pow((cos(fi)),2)+pow(b,2)*pow((sin(fi)),2))))#поправка на геоид (полярное сжатие Земли)

    N=len(IGRF_g)#-1# длина апроксимируещего ряда (максимальная степень сферических гармоник)
    F_IGRF_g = [0]*N
    F_IGRF_h = [0]*N
    #***Актуализация матриц сферических гармонических коэффициентов
    for i in range(0, N):#for (i=0 i<=N i++)
        F_IGRF_g[i] = [0]*N
        F_IGRF_h[i] = [0]*N
        for j in range(0, N):#for (j=0 j<=N j++)
             F_IGRF_g[i][j]=IGRF_g[i][j]+(SV_g[i][j])*(year-Age)
             F_IGRF_h[i][j]=IGRF_h[i][j]+(SV_h[i][j])*(year-Age)


#******************Функция расчета произведения нечетных составляющих ряда сферических гармоник******************
    def PI_odd(i):

         rez=1
         for k in range(1, i+1):#for (k=1 k<(i+1) k++)
            rez1=2*k-1
            rez=rez*rez1

         return rez


#************************************Функция расчета нормировачного множителя************************************
    def epsilon(i): 
        if (i<1):
             eps=1
        else:
            eps=2
        return eps


#function factorial(c)
#{
  #return c?c*factorial(c-1):1
#}
#*****************Функция расчета потенциала индукции геомагнитного поля внутреземных источников _U(_r,_lamda,_tetta)*****************
    def U(r,lamda,teta):
        #global N,R,F_IGRF_g,F_IGRF_h
        sum_n=0  # суммирование п, 
        for n in range(1, N):#for (n=1 n<=N n++) # N - максимальная степень нормированных по Шмидту присоединенных функций Лежандра
    #{
            sum_m=0 
            for m in range(0, n+1):#for (m=0 m<=n m++)  # суммирование по m

#{
               half_REZ=R*(F_IGRF_g[n][m]*cos(m*lamda)+F_IGRF_h[n][m]*sin(m*lamda))*pow((R/r),(n+1)) *        PI_odd(n)*sqrt(epsilon(m)/(factorial (n+m)*factorial (n-m)))*pow((sin(teta)),m)* (pow(cos(teta),(n-m))-((n-m)*(n-m-1)/(2*(2*n-1)))*pow((cos(teta)),(n-m-2))+ ((n-m)*(n-m-1)*(n-m-2)*(n-m-3)/(2*4*(2*n-1)*(2*n-3)))*pow((cos(teta)),(n-m-4))-                              ((n-m)*(n-m-1)*(n-m-2)*(n-m-3)*(n-m-4)*(n-m-5)/(2*4*6*(2*n-1)*(2*n-3)*(2*n-5)))*pow((cos(teta)),(n-m-6))+   ((n-m)*(n-m-1)*(n-m-2)*(n-m-3)*(n-m-4)*(n-m-5)*(n-m-6)*(n-m-7)/(2*4*6*8*(2*n-1)*(2*n-3)*(2*n-5)*(2*n-7)))*pow((cos(teta)),(n-m-8))-   ((n-m)*(n-m-1)*(n-m-2)*(n-m-3)*(n-m-4)*(n-m-5)*(n-m-6)*(n-m-7)*(n-m-8)*(n-m-9)/(2*4*6*8*10*(2*n-1)*(2*n-3)*(2*n-5)*(2*n-7)*(2*n-9)))*pow((cos(teta)),(n-m-10))+      ((n-m)*(n-m-1)*(n-m-2)*(n-m-3)*(n-m-4)*(n-m-5)*(n-m-6)*(n-m-7)*(n-m-8)*(n-m-9)*(n-m-10)*(n-m-11)/(2*4*6*8*10*12*(2*n-1)*(2*n-3)*(2*n-5)*(2*n-7)*(2*n-9)*(2*n-11)))* pow(cos(teta),(n-m-12)))
               sum_m=sum_m+half_REZ
             # }
            sum_n=sum_n+sum_m
#}
        potential=sum_n
        return potential
#}


# функция расчета производной dU/dlamda
    def dUdlamda(lamda0): 
#{
        #global r,teta
#
##********************ИСХОДНЫЕ ДАННЫЕ********************
#***********Без необходимости менять не нужно***********
        h0=1                    # оптимальный шаг дискретизации (изначально не известен)
        h=0                     # задаемся изначальным шагом дискретизации = 1 (пока он равен нулю - издержки алгоритма, позже примет значение 1)
        e=1*pow (10,(-9))       # задаемся погрешностью округления с точностью до 9-го знака после запятой (количество знаков после запятой значения аргумента Y(X))
#********************************************************

        while ((abs(h-h0))>0.000000001):
             h=h0
             X=[0]*6
             Y=[0]*6

             for i in range(6):#for (i = 0 i<=5 i++)
#{X[i]=lamda0+i*h}
                X[i] = lamda0+i*h
             for i in range(6):#for (i = 0 i<=5 i++)
#{Y[i] = U(r, X[i], teta)}
                 Y[i] =   U(r, X[i], teta)

             deltaY1=Y[1]-Y[0]
             deltaY2=Y[2]-Y[1]-deltaY1
             deltaY3=((Y[3]-Y[2])-(Y[2]-Y[1]))-deltaY2
             deltaY4=(((Y[4]-Y[3])-(Y[3]-Y[2]))-((Y[2]-Y[1])-(Y[1]-Y[0])))-deltaY3
             deltaY5=(((Y[5]-Y[4])-(Y[4]-(Y[3])))-((Y[3]-Y[2])-(Y[2]-Y[1])))-deltaY4

             d2y = (1/pow(h,2))*(deltaY2-deltaY3+(11/12)*deltaY4-(5/6)*deltaY5) 

             h0 = sqrt(4*(abs((e*Y[0])/(d2y))))

        h = h0
        dy = (1/h)*(deltaY1-(1/2)*deltaY2+(1/3)*deltaY3)
        return dy


# функция расчета производной dU/dteta
    def dUdteta(teta0): 
        print(r)
        #global r
        #global lamda
        print(r)
#
##********************ИСХОДНЫЕ ДАННЫЕ********************
#***********Без необходимости менять не нужно***********
        h0=1                    # оптимальный шаг дискретизации (изначально не известен)
        h=0                     # задаемся изначальным шагом дискретизации = 1 (пока он равен нулю - издержки алгоритма, позже примет значение 1)
        e=1*pow (10,(-9))       # задаемся погрешностью округления с точностью до 9-го знака после запятой (количество знаков после запятой значения аргумента Y(X))
#********************************************************

        while ((abs(h-h0))>0.000000001): 
            h=h0

            X=[0]*6
            Y=[0]*6

            for i in range(6):#for (i = 0 i<=5 i++)
               X[i]=teta0+i*h

            for i in range(6):#for (i = 0 i<=5 i++)
                Y[i] = U(r, lamda, X[i])

            deltaY1=Y[1]-Y[0]
            deltaY2=Y[2]-Y[1]-deltaY1
            deltaY3=((Y[3]-Y[2])-(Y[2]-Y[1]))-deltaY2
            deltaY4=(((Y[4]-Y[3])-(Y[3]-Y[2]))-((Y[2]-Y[1])-(Y[1]-Y[0])))-deltaY3
            deltaY5=(((Y[5]-Y[4])-(Y[4]-(Y[3])))-((Y[3]-Y[2])-(Y[2]-Y[1])))-deltaY4

            d2y = (1/pow(h,2))*(deltaY2-deltaY3+(11/12)*deltaY4-(5/6)*deltaY5) 

            h0 = sqrt(4*(abs((e*Y[0])/(d2y))))

        h = h0
        dy = (1/h)*(deltaY1-(1/2)*deltaY2+(1/3)*deltaY3)
        return dy


# функция расчета производной dU/dr
    def dUdr(r0): 

       #global teta,lamda
#
##********************ИСХОДНЫЕ ДАННЫЕ********************
#***********Без необходимости менять не нужно***********
       h0=1                    # оптимальный шаг дискретизации (изначально не известен)
       h=0                     # задаемся изначальным шагом дискретизации = 1 (пока он равен нулю - издержки алгоритма, позже примет значение 1)
       e=1*pow (10,(-9))       # задаемся погрешностью округления с точностью до 9-го знака после запятой (количество знаков после запятой значения аргумента Y(X))
#********************************************************
       while ((abs(h-h0))>0.000000001) :
            h=h0

            X=[0]*6
            Y=[0]*6

            for i in range(6): #for (i = 0 i<=5 i++)
                X[i]=r0+i*h

            for i in range(6):# for (i = 0 i<=5 i++)
                Y[i] = U(X[i], lamda,teta)

            deltaY1=Y[1]-Y[0]
            deltaY2=Y[2]-Y[1]-deltaY1
            deltaY3=((Y[3]-Y[2])-(Y[2]-Y[1]))-deltaY2
            deltaY4=(((Y[4]-Y[3])-(Y[3]-Y[2]))-((Y[2]-Y[1])-(Y[1]-Y[0])))-deltaY3
            deltaY5=(((Y[5]-Y[4])-(Y[4]-(Y[3])))-((Y[3]-Y[2])-(Y[2]-Y[1])))-deltaY4

            d2y = (1/pow(h,2))*(deltaY2-deltaY3+(11/12)*deltaY4-(5/6)*deltaY5) 

            h0 = sqrt(4*(abs((e*Y[0])/(d2y))))

       h = h0
       dy = (1/h)*(deltaY1-(1/2)*deltaY2+(1/3)*deltaY3)
       return dy


#составляющие вектора индукции геомагнитного поля внутриземных источников
    BX=(1/r)*dUdteta(teta)
    try:
        BY=(-1/(r*sin(teta)))*dUdlamda(lamda)
    except ZeroDivisionError:
        BY=0
    BZ=dUdr(r) 

# прямоугольные составляющи вектора индукции в точке с координатами fi, lamda,r, [нТл]
    Bx=BX*cos(fi-fi_sh)+BZ*sin(fi-fi_sh)
    By=BY
    Bz=BZ*cos(fi-fi_sh)-BX*sin(fi-fi_sh)       

# полный вектор геомагнитного поля анутриземных исочников, [нТл]
    B = sqrt(pow(Bx,2)+pow(By,2)+pow(Bz,2))

#Магнитное склонение, [град]
    D =(180/pi)*atan(By/Bx)
#Магнитное наклонение, [град]
    I =(180/pi)* asin(Bz/B)

# Широта северного магнитного полюса
    FI=(180/  pi)*atan(IGRF_g[1][0]/sqrt(pow(IGRF_g[1][1],2)+pow(IGRF_h[1][1],2)))

#Долгота северного магнитного полюса
    LAMDA=(180/  pi)*atan(IGRF_h[1][1]/IGRF_g[1][1])         

# Магнитный момент геомагнитного диполя
    M=pow(r,3)*sqrt(pow(IGRF_g[1][0],2)+pow(IGRF_g[1][1],2)+pow(IGRF_h[1][1],2)) 
 
    U = U(r, lamda, teta)
  
  
    def coords(UT, n_p, v, Ynum, teta, lamda, alt,typ):

	# B2 - вектор индукции магнитного поля магнитосферных токов, вычисляемый солнечно-магнитосферной системе координат
	# Ynum - порядковый номер дня в году [1..365]
	# n_p - концентрация протонов в солнечном ветре [м^-3]
	# n_alpha - концентрация альфа-частиц в солнечном ветре [м^-3]
	# n_m - концентрация малых ионных компонентов [м^-3]
	# psi - угол наклона геомагнитного диполя к плоскости ортогональной линии Земля-Солнце, [град]
	# v - скорость солнечного ветра
	# X, Y, Z - Солнечно-магнитосферные координаты в единицах [R - радиус Земли]
	# teta, lamda, alt - географические координаты

        R=6371.032          # Средний радиус Земли   

        n_alpha = 0.06*n_p # Расчет концентрации альфа-частиц в солнечном ветре [м^-3]
        n_m = 0.001*n_p    # Расчет концентрации малых ионных компонентов [м^-3]

#---Перевод вектора индукции магнитного поля из географическй системы координат в солнечно-магнитосферную---
        alpha1 = (pi/180)*11.43 # угол между осью вращения Земли и осью геомагнитного диполя
        alpha2 = (pi/180)*23.5  # угол наклона плоскости экватора к плоскости эклиптики
        U0 = 12 #часов
        K = 15 # градусов/час
        fi_SE = (pi/180)*(360*(172-Ynum)/365) # угол между линией Земля-Солнце и проекцией оси вращения Земли на плоскость эклиптики, [град]

        fi_m = (pi/180)*(K*UT-69) # угол между плоскостью полуночного мередиана и мередианальной плоскостью, содержащей северный магнитный полюс
        beta0 = asin(sin(alpha2)*cos(fi_SE)) # Склонение Солнца
        psi = asin(-sin(beta0)*cos(alpha1)+cos(beta0)*sin(alpha1)*cos(fi_m)) # угол наклона геомагниного диполя к плоскости ортогональной линии Земля-Солнце

        beta1 = (K*(UT-U0))*pi/180 # западная долгота полуденного мередиана
        beta2= acos((cos(alpha1)+sin(beta0)*sin(psi))/cos(psi)*cos (beta0))#угол между полуденным географическим меридианом и плоскостью y = 0 в солнечно магнитосферных координатах

        T_array = [[cos(beta1)*cos(beta0),                                          (-1)*sin(beta1)*cos(beta0),                                      sin(beta0)], 
	   [sin(beta1)*cos(beta2)-cos(beta1)*sin(beta0)*sin(beta2),       cos(beta1)*cos(beta2)+sin(beta1)*sin(beta0)*sin(beta2),       cos(beta0)*sin(beta2)],  # Матрица поворота к солнечно-магнитосферным координатам
	   [(-1)*sin(beta1)*sin(beta2)-cos(beta1)*sin(beta0)*cos(beta2),  (-1)*cos(beta1)*sin(beta2)+sin(beta1)*sin(beta0)*cos(beta2),  cos(beta0)*cos(beta2)]]

        S_array = [[sin(teta)*cos(lamda),                                           cos(teta)*cos(lamda),                                            (-1)*sin(lamda)], 
	   [sin(teta)*sin(lamda),                                            cos(teta)*sin(lamda),                                            cos(lamda)],                    # Матрица перевода из сферических в декартовы координаты
	   [cos(teta),                                                        (-1)*sin(teta),                                                    0]]

        Q_array0 = [0]*3 
        Q_array1 = [0]*3 
        Q_array2 = [0]*3
        Q_array = [Q_array0, Q_array1, Q_array2]

        Q_array [0][0] = T_array [0][0]*S_array[0][0]+T_array [0][1]*S_array[1][0]+T_array [0][2]*S_array[2][0]
        Q_array [0][1] = T_array [0][0]*S_array[0][1]+T_array [0][1]*S_array[1][1]+T_array [0][2]*S_array[2][1]

        Q_array [0][2] = T_array [0][0]*S_array[0][2]+T_array [0][1]*S_array[1][2]+T_array [0][2]*S_array[2][2] #!

        Q_array [1][0] = T_array [1][0]*S_array[0][0]+T_array [1][1]*S_array[1][0]+T_array [1][2]*S_array[2][0]
        Q_array [1][1] = T_array [1][0]*S_array[0][1]+T_array [1][1]*S_array[1][1]+T_array [1][2]*S_array[2][1]
        Q_array [1][2] = T_array [1][0]*S_array[0][2]+T_array [1][1]*S_array[1][2]+T_array [1][2]*S_array[2][2]
        Q_array [2][0] = T_array [2][0]*S_array[0][0]+T_array [2][1]*S_array[1][0]+T_array [2][2]*S_array[2][0]
        Q_array [2][1] = T_array [2][0]*S_array[0][1]+T_array [2][1]*S_array[1][1]+T_array [2][2]*S_array[2][1]
        Q_array [2][2] = T_array [2][0]*S_array[0][2]+T_array [2][1]*S_array[1][2]+T_array [2][2]*S_array[2][2]

        spherCoord =  [alt, teta, lamda]
        X = Q_array [0][0]*spherCoord[0]+Q_array [0][1]*spherCoord[1]+Q_array [0][2]*spherCoord[2] 
        Y = Q_array [1][0]*spherCoord[0]+Q_array [1][1]*spherCoord[1]+Q_array [1][2]*spherCoord[2] 
        Z = Q_array [2][0]*spherCoord[0]+Q_array [2][1]*spherCoord[1]+Q_array [2][2]*spherCoord[2]
 

        if(typ=="X"):
            return X
    
        if(typ=="Y"):
           return Y
        
        if(typ=="Z"):
            return Z
         

 #       	lat = float(request.GET['lat'])
	#lng = float( request.GET['lng'])
	#alt = float(request.GET['alt'])
	#data = float(request.GET['data'])
	#h =
	#
	 
    UT = float(request.GET['h'])#_GET['h']

    n_p = 3800000
    v = 415100
    datenow = date.today()
    Ynum = days_z(datenow.year, datenow.month, datenow.day)  ##date("z") + 1
    #Ynum =   #date("z")+1

    X_ = coords(UT, n_p, v, Ynum, teta, lamda, alt, "X")
    Y_ = coords(UT, n_p, v, Ynum, teta, lamda, alt, "Y")
    Z_ = coords(UT, n_p, v, Ynum, teta, lamda, alt, "Z")



###########


#Сферические гармонические коэффициенты для эпохи 2015-2020
    h11_igrf = 4797.1 
    g11_igrf = -1501   
    g10_igrf = -29442 

    g10_sv = 10.3
    g11_sv = 18.1
    h11_sv = -22.6

    h11 = h11_igrf + h11_sv * (year - Age)
    g11 = g11_igrf + g11_sv * (year - Age)
    g10 = g10_igrf + g10_sv * (year - Age)

# Большая и малая полуось земного ээлипсоида по Красовскому
    a = 6378.245
    b = 6356.863019

#координаты в географической системе (GEO), переведенные в радианы
    latGEO = north*(pi/180)    
    longGEO = east*(pi/180)   
    altGEO = alt              

    rE = sqrt(
    pow(altGEO, 2) + 2 * altGEO * sqrt(pow(a, 2) * pow(cos(latGEO), 2) + pow(b,2) * pow(sin(latGEO), 2)) + 
    (pow(a, 4) * pow(cos(latGEO), 2) + pow(b, 4) * pow(sin(latGEO), 2)) /
    (pow(a, 2) * pow(cos(latGEO), 2) + pow(b, 2) * pow(sin(latGEO), 2))
    )

#расчет углов поворота

#угол поворотота вокруг оси Y
    lamda = atan(h11 / g11)
    try:
        fi = ((pi / 2) - asin((g11 * cos(lamda) + h11 * sin(lamda))/ (g10))) - pi/2
    except ValueError:
         fi=0

#перевод в геоцентрическую систему
    xGEO = rE * cos(latGEO) * cos(longGEO)
    yGEO = rE * cos(latGEO) * sin(longGEO)
    zGEO = rE * sin(latGEO)

#матрица координат GEO
#GEO = array(3)
#GEO[0] = xGEO
#GEO[1] = yGEO
#GEO[2] = zGEO
    GEO = [xGEO, yGEO, zGEO]


#Поворотные матрицы 3x3
#   t5Y = array(3)
#   for(i = 0 i < count(t5Y) i++){
#    t5Y[i] = array(3)    
#}
    t5Y = [0]*3
    t5Y[0]=[0]*3
    t5Y[1]=[0]*3
    t5Y[2]=[0]*3


    t5Y[0][0] = cos(fi)
    t5Y[0][1] = 0
    t5Y[0][2] = sin(fi)
    t5Y[1][0] = 0
    t5Y[1][1] = 1
    t5Y[1][2] = 0
    t5Y[2][0] = -sin(fi)
    t5Y[2][1] = 0
    t5Y[2][2] = cos(fi)






    t5Z = [0]*3
    t5Z[0]=[0]*3
    t5Z[1]=[0]*3
    t5Z[2]=[0]*3
    
    t5Z[0][0] = cos(lamda)
    t5Z[0][1] = sin(lamda)
    t5Z[0][2] = 0
    t5Z[1][0] = -sin(lamda)
    t5Z[1][1] = cos(lamda)
    t5Z[1][2] = 0
    t5Z[2][0] = 0
    t5Z[2][1] = 0
    t5Z[2][2] = 1

#Умножение матриц: t5 = t5Y*t5Z
    t5 = [0]*3
    t5[0]=[0]*3
    t5[1]=[0]*3
    t5[2]=[0]*3

    t5[0][0] = (t5Y[0][0] * t5Z[0][0]) + (t5Y[0][1] * t5Z[1][0]) + (t5Y[0][2] * t5Z[2][0])
    t5[0][1] = (t5Y[0][0] * t5Z[0][1]) + (t5Y[0][1] * t5Z[1][1]) + (t5Y[0][2] * t5Z[2][1])
    t5[0][2] = (t5Y[0][0] * t5Z[0][2]) + (t5Y[0][1] * t5Z[1][2]) + (t5Y[0][2] * t5Z[2][2])

    t5[1][0] = (t5Y[1][0] * t5Z[0][0]) + (t5Y[1][1] * t5Z[1][0]) + (t5Y[1][2] * t5Z[2][0])
    t5[1][1] = (t5Y[1][0] * t5Z[0][1]) + (t5Y[1][1] * t5Z[1][1]) + (t5Y[1][2] * t5Z[2][1])
    t5[1][2] = (t5Y[1][0] * t5Z[0][2]) + (t5Y[1][1] * t5Z[1][2]) + (t5Y[1][2] * t5Z[2][2])

    t5[2][0] = (t5Y[2][0] * t5Z[0][0]) + (t5Y[2][1] * t5Z[1][0]) + (t5Y[2][2] * t5Z[2][0])
    t5[2][1] = (t5Y[2][0] * t5Z[0][1]) + (t5Y[2][1] * t5Z[1][1]) + (t5Y[2][2] * t5Z[2][1])
    t5[2][2] = (t5Y[2][0] * t5Z[0][2]) + (t5Y[2][1] * t5Z[1][2]) + (t5Y[2][2] * t5Z[2][2])


#Умножение матриц: MAG = t5*tGEO
    MAG = [0]*3
    MAG[0] = (t5[0][0] * GEO[0]) + (t5[0][1] * GEO[1]) + (t5[0][2] * GEO[2])
    MAG[1] = (t5[1][0] * GEO[0]) + (t5[1][1] * GEO[1]) + (t5[1][2] * GEO[2])
    MAG[2] = (t5[2][0] * GEO[0]) + (t5[2][1] * GEO[1]) + (t5[2][2] * GEO[2])

#пересчет в  град
    latMAG = atan((MAG[2]) / (sqrt(pow(MAG[0], 2) + pow(MAG[1], 2)))) * (180/pi)
    if(MAG[1] > 0):
        longMAG = acos((MAG[0]) / (sqrt(pow(MAG[0],2) + pow(MAG[1], 2)))) * (180/pi)
    else:
      longMAG = 360 - (acos((MAG[0]) / (sqrt(pow(MAG[0],2) + pow(MAG[1],2)))) * (180/pi))


#echo latMAG
#echo '<br/>'
#echo longMAG
###########

    proto_f = [0]*16
    proto_f[0] = teta
    proto_f[1] = lamda
    proto_f[2] = N
    proto_f[3] = U
    proto_f[4] = Bx
    proto_f[5] = By
    proto_f[6] = Bz
    proto_f[7] = B
    proto_f[8] = D
    proto_f[9] = I
    proto_f[10] = FI
    proto_f[11] = LAMDA
    proto_f[12] = M
    proto_f[13] = latMAG
    proto_f[14] = longMAG
    proto_f[15] = sqrt(pow(MAG[0],2) + pow(MAG[1],2) + pow(MAG[2],2))

    	#proto_f = calculate(lat, lng, alt, data, h)
    jsonStringBx = json.dumps(proto_f)
    return 	HttpResponse(jsonStringBx)

#jsonStringBx = json_encode(proto_f)
#echo jsonStringBx

  
  #response =  '<?xml version="1.0" encoding="windows-1251" standalone="yes"?>'.
  #            '<response>'.
  #              '<lamda>'.
  #              teta.
  #              '</lamda>'.
  #              '<teta>'.
  #              lamda.
  #              '</teta>'.
  #              '<N>'.
  #              N.
  #              '</N>'.	
  #              '<U>'.
  #              U.
  #              '</U>'.	
		#		'<Bx>'.
  #              Bx.
  #              '</Bx>'.
  #              '<By>'.
  #              By.
  #              '</By>'.
  #              '<Bz>'.
  #              Bz.
  #              '</Bz>'.	
  #              '<B>'.
  #              B.
  #              '</B>'.				
  #              '<D>'.
  #              D.
  #              '</D>'.						
  #              '<I>'.
  #              I.
  #              '</I>'.	
		#		'<FI>'.
  #              FI.
  #              '</FI>'.	
  #              '<LAMDA>'.
  #              LAMDA.
  #              '</LAMDA>'.	
  #              '<M>'.
  #              M.
  #              '</M>'.	
  #              '<X_>'.
  #              X_.
  #              '</X_>'.
  #              '<Y_>'.
  #              Y_.
  #              '</Y_>'.  
  #              '<Z_>'.
  #              Z_.
  #              '</Z_>'.                
  #            '</response>'







