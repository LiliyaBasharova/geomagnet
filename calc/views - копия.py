# -*- coding: utf-8 -
from django.shortcuts import render
from django.http import HttpResponse
from datetime import *
import json
from math import *
from random import randint, uniform, seed, choice
from numpy import dot
import time


def days_z(year, month, day):
    """
    Номер дня от начала года
    вход year - год, month - номер месяца, day - номер день в месяце
    """
    #               ян фе ма ап ма ию ию ав се ок но де
    day_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if year % 4 == 0:
        day_in_month[1] += 1#високосный год

    sum = 0
    for i in range(month - 1):
        sum += day_in_month[i]
    sum += day
    return sum

	
def calc(request):
    north = float(request.GET['lat'])#_GET['lat']#северная широта (южная со знаком "-")
    east = float( request.GET['lng'])#_GET['lng']# восточная долгота (западная со знаком"-")
    alt = float(request.GET['alt'])#_GET['alt']# высота над уровнем моря, км
    year = float(request.GET['data'])#_GET['data']# текущая дата.  (например 30 июня 2015 года запишется 2015.5)

#ФИЗИЧЕСКИЕ (ИНВАРИАНТНЫЕ) ПАРАМЕТРЫ ЗЕМЛИ\n")
    R = 6371.032   #Средний радиус Земли, [км]
    a = 6378.245 #Большая полуось Земного элепсоида вращения, [км] # Эллипсоид Красовского
    b = 6356.863019 #Малая полуось Земного элепсоида вращения, [км] # Эллипсоид Красовского
    Age = 2015.0    #Эпоха
#***матрицы сферических гармонических коэффициентов (для эпохи 2015г.)
    IGRF_g = [[0,          0,         0,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [-29438.5,    -1501.1,         0,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [-2445.3,     3012.5,    1676.6,         0,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [1351.1,    -2352.3,    1225.6,     581.9,        0,        0,        0,        0,       0,        0,       0,        0,    0],
        [907.2,      813.7,     120.3,    -335.0,     70.3,        0,        0,        0,       0,        0,       0,        0,    0],
        [-232.6,      360.1,     192.4,    -141.0,   -157.4,      4.3,        0,        0,       0,        0,       0,        0,    0],
        [69.5,       67.4,      72.8,    -129.8,    -29.0,     13.2,    -70.9,        0,       0,        0,       0,        0,    0],
        [81.6,      -76.1,      -6.8,      51.9,     15.0,      9.3,     -2.8,      6.7,       0,        0,       0,        0,    0],
        [24.0,        8.6,     -16.9,      -3.2,    -20.6,     13.3,     11.7,    -16.0,    -2.0,        0,       0,        0,    0],
        [5.4,        8.8,       3.1,      -3.1,      0.6,    -13.3,     -0.1,      8.7,    -9.1,    -10.5,       0,        0,    0],
        [-1.9,       -6.5,       0.2,       0.6,     -0.6,      1.7,     -0.7,      2.1,     2.3,     -1.8,    -3.6,        0,    0],
        [3.1,       -1.5,      -2.3,       2.1,     -0.9,      0.6,     -0.7,      0.2,     1.7,     -0.2,     0.4,      3.5,    0],
        [-2.0,       -0.3,       0.4,       1.3,     -0.9,      0.9,      0.1,      0.5,    -0.4,     -0.4,     0.2,     -0.9,    0]]

    IGRF_h = [[0,          0,         0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,     4796.2,         0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,    -2845.6,    -642.0,         0,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,     -115.3,     245.0,    -538.3,         0,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,      283.4,    -188.6,     180.9,    -329.5,        0,        0,        0,       0,        0,       0,       0,       0],
         [0,       47.4,     196.9,    -119.4,      16.1,    100.1,        0,        0,       0,        0,       0,       0,       0],
         [0,      -20.7,      33.2,      58.8,     -66.5,      7.3,     62.5,        0,       0,        0,       0,       0,       0],
         [0,      -54.1,     -19.4,       5.6,      24.4,      3.3,    -27.5,     -2.3,       0,        0,       0,       0,       0],
         [0,       10.2,     -18.1,      13.2,     -14.6,     16.2,      5.7,     -9.1,      2.2,       0,       0,       0,       0],
         [0,      -21.6,      10.8,      11.7,      -6.8,     -6.9,      7.8,      1.0,     -3.9,     8.5,       0,       0,       0],
         [0,        3.3,      -0.3,       4.6,       4.4,     -7.9,     -0.6,     -4.1,     -2.8,    -1.1,    -8.7,       0,       0],
         [0,       -0.1,       2.1,      -0.7,      -1.1,      0.7,     -0.2,     -2.1,     -1.5,    -2.5,    -2.0,    -2.3,       0],
         [0,       -1.0,       0.5,       1.8,      -2.2,      0.3,      0.7,     -0.1,      0.3,     0.2,    -0.9,    -0.2,     0.7]]
        
    SV_g = [[0,       0,       0,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [10.7,    17.9,       0,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [-8.6,    -3.3,     2.4,       0,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [3.1,    -6.2,    -0.4,   -10.4,       0,       0,       0,       0,      0,      0,      0,      0,    0],
       [-0.4,     0.8,    -9.2,     4.0,    -4.2,       0,       0,       0,      0,      0,      0,      0,    0],
       [-0.2,     0.1,    -1.4,     0.0,     1.3,     3.8,       0,       0,      0,      0,      0,      0,    0],
       [-0.5,    -0.2,    -0.6,     2.4,    -1.1,     0.3,     1.5,       0,      0,      0,      0,      0,    0],
       [0.2,    -0.2,    -0.4,     1.3,     0.2,    -0.4,    -0.9,     0.3,      0,      0,      0,      0,    0],
       [0.0,     0.1,    -0.5,     0.5,    -0.2,     0.4,     0.2,    -0.4,    0.3,      0,      0,      0,    0],
       [0.0,    -0.1,    -0.1,     0.4,    -0.5,    -0.1,     0.1,     0.0,   -0.2,   -0.1,      0,      0,    0],
       [0.0,     0.0,    -0.1,     0.3,    -0.1,    -0.1,    -0.1,     0.0,   -0.2,   -0.1,   -0.2,      0,    0],
       [0.0,     0.0,    -0.1,     0.1,     0.0,     0.0,     0.0,     0.0,    0.0,    0.0,   -0.1,   -0.1,    0],
       [0.1,     0.0,     0.0,     0.1,    -0.1,     0.0,     0.1,     0.0,      0,      0,      0,      0,    0]]
           
    SV_h = [[0,        0,        0,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,    -26.8,        0,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,    -27.1,    -13.8,        0,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,      8.4,     -0.4,      2.3,        0,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,     -0.6,      5.3,      3.0,     -5.3,        0,       0,       0,       0,     0,     0,     0,    0],
       [0,      0.4,      1.6,     -1.1,      3.3,      0.1,       0,       0,       0,     0,     0,     0,    0],
       [0,      0.0,     -2.2,     -0.7,      0.1,      1.0,     1.3,       0,       0,     0,     0,     0,    0],
       [0,      0.7,      0.5,     -0.2,     -0.1,     -0.7,     0.1,     0.1,       0,     0,     0,     0,    0],
       [0,     -0.3,      0.3,      0.3,      0.6,     -0.1,    -0.2,     0.3,     0.0,     0,     0,     0,    0],
       [0,     -0.2,     -0.1,     -0.2,      0.1,      0.1,     0.0,    -0.2,     0.4,   0.3,     0,     0,    0],
       [0,      0.1,     -0.1,      0.0,      0.0,     -0.2,     0.1,    -0.1,    -0.2,   0.1,  -0.1,     0,    0],
       [0,        0,      0.1,      0.0,      0.1,      0.0,     0.0,     0.1,     0.0,  -0.1,   0.0,  -0.1,    0],
       [0,        0,        0,     -0.1,      0.0,      0.0,     0.0,     0.0,       0,     0,     0,     0,    0]]

    lamda = east * (pi / 180)
    fi = north * (pi / 180)
    a2 = a ** 2
    b2 = b ** 2
    cosfi2 = (cos(fi) ** 2)
    sinfi2 = sin(fi) ** 2
    fi_sh = atan(((b2 + alt * sqrt(a2 * cosfi2 + b2 * sinfi2)) / (a2 + alt * sqrt(a2 * cosfi2 + b2 * sinfi2))) * tan(fi))#Широта в сферических координатах
    teta = (pi / 2) - fi_sh #Полярный угол
    r = sqrt((alt ** 2) + 2 * alt * sqrt(a2 * cosfi2 + b2 * sinfi2) + ((a ** 4) * cosfi2 + (b ** 4) * sinfi2) / (a2 * cosfi2 + b2 * sinfi2))#поправка на геоид (полярное сжатие Земли)

    N = len(IGRF_g)#-1# длина апроксимируещего ряда (максимальная степень сферических гармоник)
    F_IGRF_g = [0] * N
    F_IGRF_h = [0] * N
    #***Актуализация матриц сферических гармонических коэффициентов
    for i in range(0, N):#for (i=0 i<=N i++)
        F_IGRF_g[i] = [0] * N
        F_IGRF_h[i] = [0] * N
        for j in range(0, N):#for (j=0 j<=N j++)
             F_IGRF_g[i][j] = IGRF_g[i][j] + (SV_g[i][j]) * (year - Age)
             F_IGRF_h[i][j] = IGRF_h[i][j] + (SV_h[i][j]) * (year - Age)


#************************************Функция расчета нормировачного
#множителя************************************
    def epsilon(i): 
        if (i < 1):
             eps = 1
        else:
            eps = 2
        return eps


#*****************Функция расчета потенциала индукции геомагнитного поля
#внутреземных источников _U(_r,_lamda,_tetta)*****************
    def U(r,lamda,teta):
        results_PI = [1,
               1,
               3,
               15,
               105,
               945,
               10395,
               135135,
               2027025,
               34459425,
               654729075,
               13749310575,
               316234143225,
               7905853580625,
               213458046676875,
               6190283353629375,
               191898783962510625,
               6332659870762850625,
               221643095476699771875,
               8200794532637891559375]
        cos_t = cos(teta)
        sin_t = sin(teta)

        pos_ct = [0] * 30
        ind_min = -12
        ind_max = N - 1

        for i in range(ind_min - 1, ind_max + 1):
            pos_ct[i] = cos_t ** i

        pow_sin_m = [0] * 13
        for i in range(N):
            pow_sin_m[i] = sin_t ** i

        powRr = [0] * N
        for i in range(1, N):
            powRr[i] = (R / r) ** (i + 1) 
        factors = [1,
            1,
            2,
            6,
            24,
            120,
            720,
            5040,
            40320,
            362880,
            3628800,
            39916800,
            479001600,
            6227020800,
            87178291200,
            1307674368000,
            20922789888000,
            355687428096000,
            6402373705728000,
            121645100408832000,
            2432902008176640000,
            51090942171709440000,
            1124000727777607680000,
            25852016738884976640000,
            620448401733239439360000,
            15511210043330985984000000,
            403291461126605635584000000]

        sum_n = 0  # суммирование п,
        for n in range(1, N):#for (n=1 n<=N n++) # N - максимальная степень нормированных по Шмидту
                             #присоединенных функций Лежандра
            sum_m = 0
            pi_odd_n = results_PI[n]#PI_odd(n)
            for m in range(0, n + 1):#for (m=0 m<=n m++) # суммирование по m
                                    
               n_m = n - m

               pr1 = (n - m) * (n_m - 1)
               pr2 = pr1 * (n_m - 2) * (n_m - 3)
               pr3 = pr2 * (n_m - 4) * (n_m - 5)
               pr4 = pr3 * (n_m - 6) * (n_m - 7)
               pr5 = pr4 * (n_m - 8) * (n_m - 9)
               pr6 = pr5 * (n_m - 10) * (n_m - 11)

               del1 = (2 * (2 * n - 1))
               del2 = del1 * (4 * (2 * n - 3))
               del3 = del2 * 6 * (2 * n - 5)
               del4 = del3 * 8 * (2 * n - 7)
               del5 = del4 * 10 * (2 * n - 9)
               del6 = del5 * 12 * (2 * n - 11)

               s0 = pos_ct[n_m]
               s1 = (pr1 / del1) * pos_ct[n_m - 2]#pow(cos_t,(n - m - 2))
               s2 = (pr2 / del2) * pos_ct[n_m - 4]#pow(cos_t,(n - m - 4))
               s3 = (pr3 / del3) * pos_ct[n_m - 6]#pow(cos_t,(n - m - 6))
               s4 = (pr4 / del4) * pos_ct[n_m - 8]#pow(cos_t, (n - m - 8))
               s5 = (pr5 / del5) * pos_ct[n_m - 10]#pow(cos_t, (n - m - 10))
               s6 = (pr6 / del6) * pos_ct[n_m - 12]#pow(cos_t, (n - m - 12))

               a = (F_IGRF_g[n][m] * cos(m * lamda) + F_IGRF_h[n][m] * sin(m * lamda)) 
               b = epsilon(m) / (factors[n+m] * factors[n_m]) #(factorial(n + m) * factorial(n_m))
               mn = R * a * powRr[n] * pi_odd_n * sqrt(b) * pow_sin_m[m]


               half_REZ = mn * (s0 - s1 + s2 - s3 + s4 - s5 + s6)
               sum_m = sum_m + half_REZ
            sum_n = sum_n + sum_m
        potential = sum_n
        return potential
		
		
    def dydx(x0, y):
##********************ИСХОДНЫЕ ДАННЫЕ********************
#***********Без необходимости менять не нужно***********
        h0 = 1 # оптимальный шаг дискретизации (изначально не известен)
        h = 0 # задаемся изначальным шагом дискретизации = 1 (пока он
             # равен нулю - издержки алгоритма, позже примет значение 1)
        e = 1e-9#1 * pow(10,(-9)) # задаемся погрешностью округления с точностью до  9-го знака после        
        # запятой (количество знаков после запятой значения аргумента Y(X))

#********************************************************
        X = [0] * 6
        Y = [0] * 6
        while ((abs(h - h0)) > e):
             h = h0

             for i in range(6):
                X[i] = x0 + i * h

             for i in range(6):
                 Y[i] = y(X[i])

             deltaY1 = Y[1] - Y[0]
             deltaY2 = Y[2] - Y[1] - deltaY1
             deltaY3 = ((Y[3] - Y[2]) - (Y[2] - Y[1])) - deltaY2
             deltaY4 = (((Y[4] - Y[3]) - (Y[3] - Y[2])) - ((Y[2] - Y[1]) -
             (Y[1] - Y[0]))) - deltaY3
             deltaY5 = (((Y[5] - Y[4]) - (Y[4] - (Y[3]))) - ((Y[3] - Y[2]) -
             (Y[2] - Y[1]))) - deltaY4

             d2y = (1 / pow(h,2)) * (deltaY2 - deltaY3 + (11 / 12) * deltaY4 -
             (5 / 6) * deltaY5)

             h0 = sqrt(4 * (abs((e * Y[0]) / (d2y))))
        h = h0
        dy = (1 / h) * (deltaY1 - (1 / 2) * deltaY2 + (1 / 3) * deltaY3)
        return dy


# функция расчета производной dU/dlamda
    def dUdlamda(lamda0): 
        return dydx(lamda0, lambda x_l: U(r, x_l, teta))

		
# функция расчета производной dU/dteta
    def dUdteta(teta0): 
        return dydx(teta0, lambda tet: U(r, lamda, tet))

		
# функция расчета производной dU/dr
    def dUdr(r0):
        return dydx(r0, lambda x_r: U(x_r, lamda, teta))


#составляющие вектора индукции геомагнитного поля внутриземных источников
    try:
        BX = (1 / r) * dUdteta(teta)
    except ZeroDivisionError:
        BX = 1
    try:
        BY = (-1 / (r * sin(teta))) * dUdlamda(lamda)
    except ValueError:
        BY = 0
    except ZeroDivisionError:          
        BY = 0
    try:
        BZ = dUdr(r)
    except ZeroDivisionError: 
        BZ = 0
    
# прямоугольные составляющи вектора индукции в точке с координатами fi,
# lamda,r, [нТл]
    Bx = BX * cos(fi - fi_sh) + BZ * sin(fi - fi_sh)
    By = BY
    Bz = BZ * cos(fi - fi_sh) - BX * sin(fi - fi_sh)       

# полный вектор геомагнитного поля анутриземных исочников, [нТл]
    B = sqrt(Bx * Bx + By * By + Bz * Bz)

#Магнитное склонение, [град]
    D = (180 / pi) * atan(By / Bx)
#Магнитное наклонение, [град]
    I = (180 / pi) * asin(Bz / B)

# Широта северного магнитного полюса
    FI = (180 / pi) * atan(IGRF_g[1][0] / sqrt(pow(IGRF_g[1][1],2) + pow(IGRF_h[1][1],2)))

#Долгота северного магнитного полюса
    LAMDA = (180 / pi) * atan(IGRF_h[1][1] / IGRF_g[1][1])         

# Магнитный момент геомагнитного диполя
    M = pow(r,3) * sqrt(pow(IGRF_g[1][0],2) + pow(IGRF_g[1][1],2) + pow(IGRF_h[1][1],2)) 
 
    U = U(r, lamda, teta)
  
  
    def coords(UT, n_p, v, Ynum, teta, lamda, alt):
	# B2 - вектор индукции магнитного поля магнитосферных токов, вычисляемый
	# солнечно-магнитосферной системе координат
	# Ynum - порядковый номер дня в году [1..365]
	# n_p - концентрация протонов в солнечном ветре [м^-3]
	# n_alpha - концентрация альфа-частиц в солнечном ветре [м^-3]
	# n_m - концентрация малых ионных компонентов [м^-3]
	# psi - угол наклона геомагнитного диполя к плоскости ортогональной линии
	# Земля-Солнце, [град]
	# v - скорость солнечного ветра
	# X, Y, Z - Солнечно-магнитосферные координаты в единицах [R - радиус Земли]
	# teta, lamda, alt - географические координаты

        R = 6371.032          # Средний радиус Земли

        n_alpha = 0.06 * n_p # Расчет концентрации альфа-частиц в солнечном ветре [м^-3]
        n_m = 0.001 * n_p    # Расчет концентрации малых ионных компонентов [м^-3]

#---Перевод вектора индукции магнитного поля из географическй системы координат
#в солнечно-магнитосферную---
        alpha1 = (pi / 180) * 11.43 # угол между осью вращения Земли и осью геомагнитного диполя
        alpha2 = (pi / 180) * 23.5  # угол наклона плоскости экватора к плоскости эклиптики
        U0 = 12 #часов
        K = 15 # градусов/час
        fi_SE = (pi / 180) * (360 * (172 - Ynum) / 365) # угол между линией Земля-Солнце и проекцией оси вращения Земли на плоскость
                                                        # эклиптики, [град]

        fi_m = (pi / 180) * (K * UT - 69) # угол между плоскостью полуночного мередиана и мередианальной плоскостью,
                                          # содержащей северный магнитный полюс
        beta0 = asin(sin(alpha2) * cos(fi_SE)) # Склонение Солнца
        psi = asin(-sin(beta0) * cos(alpha1) + cos(beta0) * sin(alpha1) * cos(fi_m)) # угол наклона геомагниного диполя к плоскости ортогональной линии
                                                                                     # Земля-Солнце

        beta1 = (K * (UT - U0)) * pi / 180 # западная долгота полуденного мередиана
        beta2 = acos((cos(alpha1) + sin(beta0) * sin(psi)) / cos(psi) * cos(beta0))#угол между полуденным географическим меридианом и плоскостью y = 0 в солнечно
                                                                                   #магнитосферных
                                                                                                                                                                      #координатах

        T_array = [[cos(beta1) * cos(beta0),                                          (-1) * sin(beta1) * cos(beta0),                                      sin(beta0)], 
	   [sin(beta1) * cos(beta2) - cos(beta1) * sin(beta0) * sin(beta2),       cos(beta1) * cos(beta2) + sin(beta1) * sin(beta0) * sin(beta2),       cos(beta0) * sin(beta2)],  # Матрица поворота к солнечно-магнитосферным координатам
	   [(-1) * sin(beta1) * sin(beta2) - cos(beta1) * sin(beta0) * cos(beta2),  (-1) * cos(beta1) * sin(beta2) + sin(beta1) * sin(beta0) * cos(beta2),  cos(beta0) * cos(beta2)]]

        S_array = [[sin(teta) * cos(lamda),                                           cos(teta) * cos(lamda),                                            (-1) * sin(lamda)], 
	   [sin(teta) * sin(lamda),                                            cos(teta) * sin(lamda),                                            cos(lamda)],                    # Матрица перевода из сферических в декартовы координаты
	   [cos(teta),                                                        (-1) * sin(teta),                                                    0]]

        Q_array = dot(T_array, S_array)

        spherCoord = [alt, teta, lamda] 
        return dot(Q_array, spherCoord)

    UT = float(request.GET['h'])#_GET['h']
    n_p = 3800000
    v = 415100
    datenow = date.today()
    Ynum = days_z(datenow.year, datenow.month, datenow.day)  ##date("z") + 1

    (X_, Y_, Z_) = coords(UT, n_p, v, Ynum, teta, lamda, alt)



###########


#Сферические гармонические коэффициенты для эпохи 2015-2020
    h11_igrf = 4797.1 
    g11_igrf = -1501   
    g10_igrf = -29442 

    g10_sv = 10.3
    g11_sv = 18.1
    h11_sv = -22.6

    h11 = h11_igrf + h11_sv * (year - Age)
    g11 = g11_igrf + g11_sv * (year - Age)
    g10 = g10_igrf + g10_sv * (year - Age)

# Большая и малая полуось земного ээлипсоида по Красовскому
    a = 6378.245
    b = 6356.863019

#координаты в географической системе (GEO), переведенные в радианы
    latGEO = north * (pi / 180)    
    longGEO = east * (pi / 180)   
    altGEO = alt              

    rE = sqrt(pow(altGEO, 2) + 2 * altGEO * sqrt(pow(a, 2) * pow(cos(latGEO), 2) + pow(b,2) * pow(sin(latGEO), 2)) + (pow(a, 4) * pow(cos(latGEO), 2) + pow(b, 4) * pow(sin(latGEO), 2)) / (pow(a, 2) * pow(cos(latGEO), 2) + pow(b, 2) * pow(sin(latGEO), 2)))

#расчет углов поворота

#угол поворотота вокруг оси Y
    lamda = atan(h11 / g11)
    try:
        fi = ((pi / 2) - asin((g11 * cos(lamda) + h11 * sin(lamda)) / (g10))) - pi / 2
    except ValueError:
         fi = 0

#перевод в геоцентрическую систему
    xGEO = rE * cos(latGEO) * cos(longGEO)
    yGEO = rE * cos(latGEO) * sin(longGEO)
    zGEO = rE * sin(latGEO)

#матрица координат GEO
    GEO = [xGEO, yGEO, zGEO]


#Поворотные матрицы 3x3

    t5Y = [[cos(fi), 0, sin(fi)],
          [0,1, 0] ,
         [-sin(fi), 0, cos(fi)]]

    t5Z = [[cos(lamda), sin(lamda), 0],
        [-sin(lamda), cos(lamda), 0],
        [0, 0, 1]]
#Умножение матриц: t5 = t5Y*t5Z

    t5 = dot(t5Y, t5Z)

#Умножение матриц: MAG = t5*tGEO
    MAG = dot(t5, GEO)
#пересчет в град
    latMAG = atan((MAG[2]) / (sqrt(pow(MAG[0], 2) + pow(MAG[1], 2)))) * (180 / pi)
    if(MAG[1] > 0):
        longMAG = acos((MAG[0]) / (sqrt(pow(MAG[0],2) + pow(MAG[1], 2)))) * (180 / pi)
    else:
      longMAG = 360 - (acos((MAG[0]) / (sqrt(pow(MAG[0],2) + pow(MAG[1],2)))) * (180 / pi))


    proto_f = [0] * 16
    proto_f[0] = teta
    proto_f[1] = lamda
    proto_f[2] = N
    proto_f[3] = U
    proto_f[4] = Bx
    proto_f[5] = By
    proto_f[6] = Bz
    proto_f[7] = B
    proto_f[8] = D
    proto_f[9] = I
    proto_f[10] = FI
    proto_f[11] = LAMDA
    proto_f[12] = M
    proto_f[13] = latMAG
    proto_f[14] = longMAG
    proto_f[15] = sqrt(pow(MAG[0],2) + pow(MAG[1],2) + pow(MAG[2],2))

    jsonStringBx = json.dumps(proto_f)
    return 	HttpResponse(jsonStringBx)